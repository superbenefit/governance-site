---
/**
 * Policies Index Page
 *
 * Displays the main policies landing page with content from policies/index.md
 * and a directory of all policies grouped by folder.
 *
 * Features:
 * - Loads page content from governance submodule index.md
 * - Groups policies by folder with folder titles from folder index.md files
 * - Shows title, description, and status for each policy
 */
import { getCollection, render } from 'astro:content';
import StarlightPage from '@astrojs/starlight/components/StarlightPage.astro';
import { readFile } from 'node:fs/promises';
import { Marked } from 'marked';

// Try to read and parse the index.md file from the governance submodule
// Fall back to default content if the file doesn't exist (e.g., submodule not initialized)
const indexPath = './src/content/governance/policies/index.md';
let description = 'Practical coordination mechanisms across different operational domains';
let title = 'Policies';
let renderedContent = '<p>Operational policies for coordination across different domains.</p>';

try {
	const indexContent = await readFile(indexPath, 'utf-8');

	// Extract frontmatter
	const frontmatterMatch = indexContent.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
	let markdownContent = indexContent;

	if (frontmatterMatch) {
		const frontmatter = frontmatterMatch[1];
		markdownContent = frontmatterMatch[2];
		const descMatch = frontmatter.match(/description:\s*(.+)/);
		if (descMatch) {
			description = descMatch[1];
		}
	}

	// Get title from first H1 and remove it from content
	const titleMatch = markdownContent.match(/^#\s+(.+)$/m);
	title = titleMatch ? titleMatch[1] : 'Policies';
	const contentWithoutTitle = markdownContent.replace(/^#\s+.+$/m, '').trim();

	// Render markdown to HTML
	const marked = new Marked();
	renderedContent = await marked.parse(contentWithoutTitle);
} catch (error) {
	// Submodule not initialized or file doesn't exist - use defaults
	console.log('Using default policies index content');
}

// Get all policies and extract titles
const policies = await getCollection('policies');

// Extract titles from each policy
const policiesWithTitles = await Promise.all(
	policies.map(async (policy) => {
		const { headings } = await render(policy);
		const displayTitle = policy.data.title || headings.find(h => h.depth === 1)?.text || policy.id;
		return { ...policy, displayTitle };
	})
);

// Group by first folder segment
const groupedPolicies: Record<string, typeof policiesWithTitles> = {};
policiesWithTitles.forEach(policy => {
	const folder = policy.id.split('/')[0] || 'other';
	if (!groupedPolicies[folder]) {
		groupedPolicies[folder] = [];
	}
	groupedPolicies[folder].push(policy);
});

const formatFolderName = (folder: string) => {
	return folder.charAt(0).toUpperCase() + folder.slice(1);
};

// Load folder metadata from index.md files
interface FolderMetadata {
	title: string;
	description?: string;
}

async function getFolderMetadata(folder: string): Promise<FolderMetadata> {
	try {
		const indexPath = `./src/content/governance/policies/${folder}/index.md`;
		const indexContent = await readFile(indexPath, 'utf-8');

		// Extract frontmatter
		const frontmatterMatch = indexContent.match(/^---\n([\s\S]*?)\n---/);
		if (frontmatterMatch) {
			const frontmatter = frontmatterMatch[1];
			const titleMatch = frontmatter.match(/^title:\s*(.+)$/m);
			const descMatch = frontmatter.match(/^description:\s*(.+)$/m);

			return {
				title: titleMatch ? titleMatch[1].trim() : formatFolderName(folder),
				description: descMatch ? descMatch[1].trim() : undefined,
			};
		}
	} catch (error) {
		// Index file doesn't exist or couldn't be read
	}

	// Fall back to formatted folder name
	return { title: formatFolderName(folder) };
}

// Build folder metadata map
const folderMetadata = new Map<string, FolderMetadata>();
for (const folder of Object.keys(groupedPolicies)) {
	folderMetadata.set(folder, await getFolderMetadata(folder));
}
---

<StarlightPage frontmatter={{ title, description }}>
	<div class="sl-markdown-content">
		<div set:html={renderedContent} />

		<hr />

		<h2>Browse All Policies</h2>
		{Object.entries(groupedPolicies).sort().map(([folder, items]) => {
			const metadata = folderMetadata.get(folder) || { title: formatFolderName(folder) };
			return (
			<div class="policy-group">
				<h3 class="group-title">{metadata.title}</h3>
				{metadata.description && (
					<p class="group-description">{metadata.description}</p>
				)}
				<ul class="entry-list">
					{items.map(policy => (
						<li class="entry-item">
							<a href={`/policies/${policy.id}/`} class="entry-link">
								<strong class="entry-title">{policy.displayTitle}</strong>
								{policy.data.description && (
									<p class="entry-description">{policy.data.description}</p>
								)}
							</a>
							{policy.data.status && (
								<span class={`status-badge status-${policy.data.status}`}>
									{policy.data.status}
								</span>
							)}
						</li>
					))}
				</ul>
			</div>
			);
		})}
	</div>

	<style>
		hr {
			margin: var(--sb-space-12) 0;
			border: none;
			border-top: 1px solid var(--sb-border);
		}

		.policy-group {
			margin-bottom: var(--sb-space-10);
		}

		.group-title {
			font-size: var(--text-2xl, 1.5rem);
			margin-top: var(--sb-space-8);
			margin-bottom: var(--sb-space-2);
			color: var(--sl-color-gray-6);
		}

		.group-description {
			color: var(--sl-color-gray-4);
			margin: 0 0 var(--sb-space-4);
			font-size: var(--text-base, 1rem);
			line-height: 1.5;
			padding-bottom: var(--sb-space-2);
			border-bottom: 1px solid var(--sl-color-gray-5);
		}

		.entry-list {
			list-style: none;
			padding: 0;
			display: grid;
			gap: var(--sb-space-4);
		}

		.entry-item {
			background: var(--sb-surface);
			border: 1px solid var(--sb-border);
			border-radius: var(--sb-radius-lg);
			padding: var(--sb-space-6);
			box-shadow: var(--sb-shadow-sm);
			transition: all var(--sb-transition-base);
			position: relative;
		}

		.entry-item:hover {
			border-color: var(--sb-primary);
			box-shadow: var(--sb-shadow-md);
			transform: translateY(-2px);
		}

		.entry-link {
			text-decoration: none;
			color: inherit;
			display: block;
		}

		.entry-title {
			color: var(--sl-color-gray-6);
			font-size: var(--text-lg, 1.125rem);
			font-weight: 600;
			display: block;
			margin-bottom: var(--sb-space-2);
			transition: color var(--sb-transition-fast);
		}

		.entry-link:hover .entry-title {
			color: var(--sb-primary);
		}

		.entry-description {
			color: var(--sl-color-gray-4);
			margin: 0;
			font-size: var(--text-sm, 0.875rem);
			line-height: 1.5;
		}

		.status-badge {
			position: absolute;
			top: var(--sb-space-6);
			right: var(--sb-space-6);
			font-size: var(--text-xs, 0.75rem);
			padding: var(--sb-space-1-5) var(--sb-space-3);
			border-radius: var(--sb-radius-full);
			text-transform: uppercase;
			font-weight: 600;
			letter-spacing: 0.025em;
		}

		/* SuperBenefit Brand Colors for Status Badges */
		.status-draft {
			background: var(--sb-text-highlight);
			color: var(--sb-tertiary);
			border: 1px solid var(--sb-accent-warm);
		}

		.status-active {
			background: var(--sb-highlight);
			color: var(--sb-primary-dark);
			border: 1px solid var(--sb-primary-light);
		}

		.status-deprecated {
			background: var(--sb-border);
			color: var(--sb-gray);
			border: 1px solid var(--sb-lightgray);
		}

		/* Dark mode adjustments */
		[data-theme="dark"] .entry-item {
			background: var(--sl-color-gray-2);
		}

		/* Text colors use gray-6 which auto-inverts via CSS variables */
		/* group-title and entry-title already use --sl-color-gray-6 */
		/* In dark mode, gray-6 becomes light (#F5F5F5) automatically */
	</style>
</StarlightPage>
